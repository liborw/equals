#!/usr/bin/env python

""" Equals a proof of concept

Usage:
    equals [options] <infile>
    equals [options] -

Options:
    -i, --in-place                  Edit file in place
    -o OUTFILE, --output OUTFILE    Output to a file
    -e, --edits

"""

import re
import subprocess
import fileinput
import sys
from docopt import docopt

TAG = '#='

def main():

    # output is same as infile when edit in place is specified
    if opt['--in-place']:
        opt['--output'] = opt['<infile>']

    # if input from stdin then output is to stdout
    if opt['<infile>'] == '-':
        opt['--output'] = None


    # read file into list of lines, without linebreaks
    lines = []
    with fileinput.input(files=[opt['<infile>']]) as f:
        for line in f:
            lines.append(line[:-1])

    # Add print after each line with tag
    new_lines = []
    for i, line in enumerate(lines):
        new_lines.append(line)
        if '#=' in line:
            index = line.index(TAG)
            expr = line[:index].strip()
            line = gen_print_line(expr, i, index + len(TAG) + 2)
            new_lines.append(line)

    # execute the modified code
    text = '\n'.join(new_lines)
    stdout, stderr = execute(text)

    # print error and exit if there is one
    if stderr:
        print("There was an error in the input:", file=sys.stderr)
        print(stderr, file=sys.stderr)
        return

    # process the output
    for out_line in stdout.split('\n'):
        if is_print_output(out_line):
            i, start, end, value = parse_print_output(out_line)
            lines[i] = add_value(lines[i], start, end, value)

    # output
    src = '\n'.join(lines)
    if opt['--output']:
        with open(opt['--output'], 'w') as f:
            f.write(src)
    else:
        print(src, end='')


def execute(text: str):

    process = subprocess.Popen(
            ['python'],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
    )

    stdout, stderr = process.communicate(input=text.encode())

    return stdout.decode(), stderr.decode()


def gen_print_line(expr: str, line: int, start: int, end: int=-1):

    fmt_str = '_equals: {},{},{},{}'
    line = f"print('{fmt_str}'.format({line}, {start}, {end}, {expr}))"
    return line

def is_print_output(s: str):
    return s.startswith('_equals')


def parse_print_output(s: str):

    s = s[len('_equals:'):].strip()
    p1, p2, p3, *rest = s.split(',')

    # parse int
    line, start, end = int(p1), int(p2), int(p3)

    # hacky solusion for , in a value
    value = ','.join(rest)

    return line, start, end, value


def add_value(line, start, end, value):
    return line[:(start)] + " " + str(value)


if __name__ == "__main__":
    opt = docopt(__doc__)
    main()
